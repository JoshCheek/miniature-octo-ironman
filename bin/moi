#!/usr/bin/env ruby

module Moi
  class Command
    def self.call(world)
      new(world).call
    end

    attr_accessor :world
    def initialize(world)
      @world = world
    end

    def call
      raise NotImplementedError, 'I SHOULD BE IMPLEMENTED BY SUBCLASSES!'
    end

    def short_description
      raise NotImplementedError, 'I SHOULD BE IMPLEMENTED BY SUBCLASSES!'
    end

    def exit(status=0)
      world.fetch(:exit).call(status)
    end

    def env()      world.fetch(:env)    end
    def argv()     world.fetch(:argv)   end
    def stdin()    world.fetch(:stdin)  end
    def stdout()   world.fetch(:stdout) end
    def stderr()   world.fetch(:stderr) end
    def commands() world.fetch(:commands) end

    def execute(command, world_overrides={})
      new_world = world
      world_overrides.each do |k, v|
        next new_world[k] = v if new_world.key? k
        raise ArgumentError, "Not a world attribute! #{k.inspect}"
      end
      commands[command].call(world)
    end
  end
end


class Moi::TestCommand < Moi::Command
  def short_description
    'Run this binary\'s tests against itself'
  end

  def call
    require 'rspec/core'
    require 'stringio'
    specify_Moi_Command
    specify_help_command
    rspec_argv = []
    exit RSpec::Core::Runner.run(rspec_argv, stdout, stderr).to_i
  end

  # looks like there's some fancy shit I can do with hooks in the config block,
  # but wasn't really clear to me how to target them # at the level I want
  # (toplevel contexts, conditionally) without using the include/extend syntax an hooking
  # into the module's included hook, so just going to do the obvious thing.
  def add_helpers_to(suite)
    suite.send :attr_accessor, :last_exitstatus
    actual_command = self
    suite.let(:mock_env)       { {} }
    suite.let(:mock_argv)      { [] }
    suite.let(:mock_exit)      { lambda { |status| self.last_exitstatus = status } }
    suite.let(:mock_stdin)     { StringIO.new }
    suite.let(:mock_stdout)    { StringIO.new }
    suite.let(:mock_stderr)    { StringIO.new }
    suite.let(:mock_commands)  { actual_command.commands.dup }
    suite.let(:mock_world)     { {env: mock_env, argv: mock_argv, stdin: mock_stdin, stdout: mock_stdout, stderr: mock_stderr, exit: mock_exit, commands: mock_commands } }

    suite.around do |spec|
      begin  real_world           = actual_command.world
             actual_command.world = mock_world
             spec.call
      ensure actual_command.world = real_world
      end
    end

    # suite.class_eval do end
    suite.send :define_method, :add_mock_command do |name, &body|
      mock_commands[name] = Class.new(Moi::Command) { define_method(:call, &body) }
    end

    suite.send :define_method, :execute_mock_command do |world_overrides={}, &body|
      add_mock_command 'mock_command', &body
      actual_command.execute 'mock_command', world_overrides
    end

    suite.send :define_method, :execute do |command, overrides={}|
      actual_command.execute(command, overrides) # remember, we mock its workd
    end
  end


  def specify_Moi_Command
    add_helpers_to RSpec.describe('Moi::Command') {
      describe 'exit' do
        it 'defaults to 0 (success)' do
          execute_mock_command { exit }
          expect(last_exitstatus).to eq 0
        end

        it 'calls the real exit with the passed status' do
          execute_mock_command { exit 123 }
          expect(last_exitstatus).to eq 123
        end
      end

      describe 'simple accessors to the passed in hash' do
        specify '#env    returns the environment variables' do
          mock_env['PATH'] = '/p:/a'
          execute_mock_command { env['PATH'] << ':/t:/h' }
          expect(mock_env['PATH']).to eq '/p:/a:/t:/h'
        end

        specify '#argv   returns the args the process was invoked with (minus the command itself)' do
          mock_argv << '--color'
          execute_mock_command { argv << '--json' }
          expect(mock_argv).to eq ['--color', '--json']
        end

        specify '#stdout returns the standard output stream' do
          execute_mock_command { stdout.puts "Informational output" }
          expect(mock_stdout.string).to eq "Informational output\n"
        end

        specify '#stderr returns the standard error stream' do
          execute_mock_command { stderr.puts "Debugging output" }
          expect(mock_stderr.string).to eq "Debugging output\n"
        end
      end

      describe 'exectue' do
        it 'invokes the specified command' do
          seen = []
          add_mock_command('1') { seen << 'from command1' }
          add_mock_command('2') { seen << 'from command2' }

          execute_mock_command { execute '1' }
          expect(seen).to eq ['from command1']

          execute_mock_command { execute '2' }
          expect(seen).to eq ['from command1', 'from command2']
        end

        it 'accepts overrides for command\'s world attributes' do
          argv = nil
          add_mock_command('c1') { argv = self.argv }
          execute_mock_command { execute 'c1', argv: [1,2,3] }
          expect(argv).to eq [1,2,3]
        end

        it 'blows up if the overriden attribute is not a world attribute' do
          expect { execute_mock_command { execute 'c1', not_an_attribute: 1 } }
            .to raise_error ArgumentError, /not_an_attribute/
        end
      end

      describe 'short_description' do
        it 'describes what the command does' do
          expect(Moi::TestCommand.new(mock_world).short_description)
            .to eq 'Run this binary\'s tests against itself'
        end

        it 'must be overridden by subclasses' do
          expect { Class.new(Moi::Command).new(mock_world).short_description }
            .to raise_error NotImplementedError, /subclass/i
        end
      end

      describe 'call' do
        it 'is what does the command\'s work' do
          add_mock_command('c') { stdout.puts "doing work" }
          mock_command = mock_commands['c'].new(mock_world)
          expect(mock_stdout.string).to eq ""
          mock_command.call
          expect(mock_stdout.string).to eq "doing work\n"
        end

        it 'must be overridden by subclasses' do
          expect { Class.new(Moi::Command).new(mock_world).call }
            .to raise_error NotImplementedError, /subclass/i
        end
      end
    }
  end

  def specify_help_command
    add_helpers_to RSpec.describe('Moi::Command') {
      it 'prints usage info' do
        execute 'help'
        expect(mock_stdout.string).to include 'Usage'
      end

      it 'has a short description for each available command' do
        execute 'help'

        mock_commands.each do |command_name, command|
          expect(mock_stdout.string).to include command_name
          expect(mock_stdout.string).to include command.new(mock_world).short_description
        end
      end
    }
  end
end


class Moi::HelpCommand < Moi::Command
  def short_description
    'Display the help screen'
  end

  def call
    stdout.puts "Usage: moi command [arg]*"
    stdout.puts ""
    stdout.puts "Commands:"
    commands.each do |name, command|
      stdout.printf "  %-15s # %s\n", name, command.new(world).short_description
    end
  end
end


commands = {
  'test' => Moi::TestCommand,
  'help' => Moi::HelpCommand,
}


command, *argv = ARGV.dup
command = commands[command].new env:      ENV,
                                argv:     argv,
                                stdin:    $stdin,
                                stdout:   $stdout,
                                stderr:   $stderr,
                                exit:     Kernel.method(:exit),
                                commands: commands
command.call
exit 0
# sudo chruby-exec 2.1.2 -- bundle exec pumactl --config-file puma_config.rb start
