#!/usr/bin/env ruby

# TODO: no more command-names, now do 'clone' instead of Moi::CloneMoiCommand
# TODO: namespace under command
# TODO: add a specification to assert that they are subclasses of Moi::Command and they are namespaced under Moi::Command
# TODO: pull the describes out and throw them on the bottom

module Moi
  class Command
    def self.call(world)
      new(world).call
    end

    attr_accessor :world
    def initialize(world)
      @world = world
    end

    def call
      raise NotImplementedError, 'I SHOULD BE IMPLEMENTED BY SUBCLASSES!'
    end

    def short_description
      raise NotImplementedError, 'I SHOULD BE IMPLEMENTED BY SUBCLASSES!'
    end

    def exit(status=0)
      world.fetch(:exit).call(status)
    end

    def env()      world.fetch(:env)    end
    def argv()     world.fetch(:argv)   end
    def stdin()    world.fetch(:stdin)  end
    def stdout()   world.fetch(:stdout) end
    def stderr()   world.fetch(:stderr) end
    def commands() world.fetch(:commands) end

    def execute(command, world_overrides={})
      new_world = world
      world_overrides.each do |k, v|
        next new_world[k] = v if new_world.key? k
        raise ArgumentError, "Not a world attribute! #{k.inspect}"
      end
      commands[command].call(world)
    end
  end
end


class Moi::TestCommand < Moi::Command
  def short_description
    'Run this binary\'s tests against itself'
  end

  def call
    require 'rspec/core'
    require 'stringio'
    specify_Moi_Command
    specify_help_command
    specify_clone_command
    rspec_argv = [] # --fail-fast --color --format documentation
    exit RSpec::Core::Runner.run(rspec_argv, stdout, stderr).to_i
  end

  # looks like there's some fancy shit I can do with hooks in the config block,
  # but wasn't really clear to me how to target them # at the level I want
  # (toplevel contexts, conditionally) without using the include/extend syntax an hooking
  # into the module's included hook, so just going to do the obvious thing.
  def add_helpers_to(suite)
    suite.send :attr_accessor, :last_exitstatus
    pristine_commands = self.commands
    suite.let(:mock_env)       { {} }
    suite.let(:mock_argv)      { [] }
    suite.let(:mock_exit)      { lambda { |status| self.last_exitstatus = status } }
    suite.let(:mock_stdin)     { StringIO.new }
    suite.let(:mock_stdout)    { StringIO.new }
    suite.let(:mock_stderr)    { StringIO.new }
    suite.let(:mock_commands)  { pristine_commands.dup }
    suite.let(:mock_world)     { {env: mock_env, argv: mock_argv, stdin: mock_stdin, stdout: mock_stdout, stderr: mock_stderr, exit: mock_exit, commands: mock_commands } }

    suite.class_eval do
      def build_command(short_description="command from test", &body)
        Class.new Moi::Command do
          define_method(:call, &body)
          define_method(:short_description) { short_description.dup }
        end
      end

      def execute(command_name, overrides={})
        build_command { execute command_name, overrides }.new(mock_world).call
      end

      def add_command(name, &body)
        mock_commands[name] = build_command(&body)
      end

      def execute_as_command(world_overrides={}, &body)
        add_command 'mock_command', &body
        execute 'mock_command', world_overrides
      end
    end
  end


  def specify_Moi_Command
    add_helpers_to RSpec.describe(Moi::Command) {
      describe 'exit' do
        it 'defaults to 0 (success)' do
          execute_as_command { exit }
          expect(last_exitstatus).to eq 0
        end

        it 'calls the real exit with the passed status' do
          execute_as_command { exit 123 }
          expect(last_exitstatus).to eq 123
        end
      end

      describe 'simple accessors to the passed in hash' do
        specify '#env    returns the environment variables' do
          mock_env['PATH'] = '/p:/a'
          execute_as_command { env['PATH'] << ':/t:/h' }
          expect(mock_env['PATH']).to eq '/p:/a:/t:/h'
        end

        specify '#argv   returns the args the process was invoked with (minus the command itself)' do
          mock_argv << '--color'
          execute_as_command { argv << '--json' }
          expect(mock_argv).to eq ['--color', '--json']
        end

        specify '#stdout returns the standard output stream' do
          execute_as_command { stdout.puts "Informational output" }
          expect(mock_stdout.string).to eq "Informational output\n"
        end

        specify '#stderr returns the standard error stream' do
          execute_as_command { stderr.puts "Debugging output" }
          expect(mock_stderr.string).to eq "Debugging output\n"
        end
      end

      describe 'exectue' do
        it 'invokes the specified command' do
          seen = []
          add_command('1') { seen << 'from command1' }
          add_command('2') { seen << 'from command2' }

          execute_as_command { execute '1' }
          expect(seen).to eq ['from command1']

          execute_as_command { execute '2' }
          expect(seen).to eq ['from command1', 'from command2']
        end

        it 'accepts overrides for command\'s world attributes' do
          argv = nil
          add_command('c1') { argv = self.argv }
          execute_as_command { execute 'c1', argv: [1,2,3] }
          expect(argv).to eq [1,2,3]
        end

        it 'blows up if the overriden attribute is not a world attribute' do
          expect { execute_as_command { execute 'c1', not_an_attribute: 1 } }
            .to raise_error ArgumentError, /not_an_attribute/
        end
      end

      describe 'short_description' do
        it 'describes what the command does' do
          expect(Moi::TestCommand.new(mock_world).short_description)
            .to eq 'Run this binary\'s tests against itself'
        end

        it 'must be overridden by subclasses' do
          expect { Class.new(Moi::Command).new(mock_world).short_description }
            .to raise_error NotImplementedError, /subclass/i
        end
      end

      describe 'call' do
        it 'is what does the command\'s work' do
          mock_command = build_command { stdout.puts "doing work" }.new(mock_world)
          expect(mock_stdout.string).to eq ""
          mock_command.call
          expect(mock_stdout.string).to eq "doing work\n"
        end

        it 'must be overridden by subclasses' do
          expect { Class.new(Moi::Command).new(mock_world).call }
            .to raise_error NotImplementedError, /subclass/i
        end
      end
    }
  end

  def specify_help_command
    add_helpers_to RSpec.describe(Moi::HelpCommand) {
      it 'prints usage info' do
        execute 'help'
        expect(mock_stdout.string).to include 'Usage'
      end

      it 'has a short description for each available command' do
        execute 'help'

        mock_commands.each do |command_name, command|
          expect(mock_stdout.string).to include command_name
          expect(mock_stdout.string).to include command.new(mock_world).short_description
        end
      end
    }
  end

  def specify_clone_command
    add_helpers_to RSpec.describe(Moi::CloneMoiCommand) {
      it 'clones the github source to ~/moi-source' do
        pending 'needs a home, sh, and path command'
        execute 'clone'
      end
    }
  end
end


class Moi::HelpCommand < Moi::Command
  def short_description
    'Display the help screen'
  end

  def call
    stdout.puts "Usage: moi command [arg]*"
    stdout.puts ""
    stdout.puts "Commands:"
    commands.each do |name, command|
      stdout.printf "  %-15s # %s\n", name, command.new(world).short_description
    end
  end
end


class Moi::CloneMoiCommand < Moi::Command
  def short_description
    'Clones the Moi source code to ~/moi-source'
  end

  def call
    raise NotImplementedError
    # sh "git clone https://github.com/JoshCheek/miniature-octo-ironman.git #{path home, '/moi-source'}"
  end
end


commands = {
  'test'  => Moi::TestCommand,
  'help'  => Moi::HelpCommand,
  'clone' => Moi::CloneMoiCommand,
}

# TODO: ADD home TO WORLD
# TODO: ADD sh COMMAND
command, *argv = ARGV.dup
command = commands[command].new env:      ENV,
                                argv:     argv,
                                stdin:    $stdin,
                                stdout:   $stdout,
                                stderr:   $stderr,
                                exit:     Kernel.method(:exit),
                                commands: commands
command.call
exit 0
# sudo chruby-exec 2.1.2 -- bundle exec pumactl --config-file puma_config.rb start
